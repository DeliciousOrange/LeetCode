# 思路（C#）
给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。  
nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。  
示例 1:  
输入: nums1 = [4,1,2], nums2 = [1,3,4,2]   
输出: [-1,3,-1]  
解释:  
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。  
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。  
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。  

Solution1是最初始的实现版本，效率有点低下，代码中充满了for循环和while循环，而且标志位使用了一个数组来实现，空间消耗大而且效率低下。

Solution2使用了一个HashMap存储传入的nums2，在for循环遍历时直接从nums2中等于nums1[i]的下标处开始遍历，相比Solution1减少了很多无用功，因此效率更加好。
 
Solution3使用了单调递减栈的技巧。我们看下面的例子：  
假设有一个递减序列且最后一个元素开始递增，例如:[3,2,1,4]那么我们可以看出4是所有之前元素的下一个更大的元素。  

有了上面的认识，我们就可以使用一个栈来维护一个单调递减的子序列，每当有一个比stack.peek()更大的元素x，我们就弹出所有比x小的元素，对于这些比x小的元素而言，他们的下一个更大的元素就是x。
比如:[6,4,3,2,1,5],我们首先将6,4,3,2,1压入栈中，当遇到5的时候，5大于1，所以开始弹出栈元素，一直弹出到4为止。